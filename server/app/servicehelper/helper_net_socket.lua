--local skynet = require "skynet"
--local gameconstants = require "app.config.gameconstants";
--local network =  require "app.servicehelper.network";
--local sproto = require "sproto"
--
--
--local proto = nil
--    
--
--local  m_gameid,m_body_size_limit ,m_srv_net_work ; 
--
--
--
--local root = {}
--
--
----吧基础的数据丢进来 
--function root.init(gameid, body_size_limit,srv_net_work)
--   m_gameid = gameid;
--   m_body_size_limit = body_size_limit
--   m_srv_net_work = srv_net_work
--  
--  local filename = string.format("proto.game_%s.sproto", gameid)
--  proto = require (filename);
--end
--
--
--
--
--
--local REQUEST = {}
--
--function REQUEST:say()
--    print("say", self.name, self.msg)
--end
--
--function REQUEST:handshake()
--    print("handshake")
--end
--
--function REQUEST:quit()
--    print("quit")
--end
--local function request(name, args, response)
--    local f = assert(REQUEST[name])
--    local r = f(args)
--    if response then
--        -- 生成回应包(response是一个用于生成回应包的函数。)
--        -- 处理session对应问题
--        -- return response(r)
--    end
--end
--
--
--
--
--
----socket解析 
--function root.on_socket(socket, fd, addr)
--   -- 每当 accept 函数获得一个新的 socket id 后，并不会立即收到这个 socket 上的数据。这是因为，我们有时会希望把这个 socket 的操作权转让给别的服务去处理。
--    -- 任何一个服务只有在调用 socket.start(id) 之后，才可以收到这个 socket 上的数据。
--
--    --socket.start(fd)
--    local host = sproto.new(proto.c2s):host "package"
--    -- request = host:attach(sproto.new(proto.c2s))
--
--    while true do
--        local str = socket.read(fd)
--        if str then
--            local type,str2,str3,str4 = host:dispatch(str)
--
--            if type=="REQUEST" then --请求
--                -- REQUEST : 第一个返回值为 "REQUEST" 时，表示这是一个远程请求。如果请求包中没有 session 字段，表示该请求不需要回应。
--                --这时，第 2 和第 3 个返回值分别为消息类型名（即在 sproto 定义中提到的某个以 . 开头的类型名），以及消息内容（通常是一个 table ）；
--                --如果请求包中有 session 字段，那么还会有第 4 个返回值：一个用于生成回应包的函数。
--                local ok, result = pcall(request, str2,str3,str4)
--                if ok then
--                    if result then
--                        socket.write(fd, "收到了")
--                        -- 暂时不使用回应包回应
--                        -- print("response:"..result)
--                        -- send_package(id,result)
--                    end
--                else
--                    skynet.error(result)
--                end
--            end
--
--            if type=="RESPONSE" then --回应
--                -- RESPONSE ：第一个返回值为 "RESPONSE" 时，第 2 和 第 3 个返回值分别为 session 和消息内容。消息内容通常是一个 table ，但也可能不存在内容（仅仅是一个回应确认）。
--                -- 暂时不处理客户端的回应
--                print("client response")
--            end         
--
--        else
--            socket.close(fd)
--            return
--        end
--    end
--end
--
--
--return root
